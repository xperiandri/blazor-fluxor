using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;
using Blazor.Fluxor.Temporary;
using Microsoft.AspNetCore.Blazor;
using Microsoft.AspNetCore.Blazor.RenderTree;

namespace Blazor.Fluxor
{
	public class Store : IStore
	{
		public IEnumerable<IFeature> Features => FeaturesByName.Values;

		private readonly Dictionary<string, IFeature> FeaturesByName = new Dictionary<string, IFeature>(StringComparer.InvariantCultureIgnoreCase);
		private readonly Dictionary<Type, List<IEffect>> EffectsByActionType = new Dictionary<Type, List<IEffect>>();
		private readonly List<IMiddleware> Middlewares = new List<IMiddleware>();
		private readonly List<IMiddleware> ReversedMiddlewares = new List<IMiddleware>();

		private int BeginMiddlewareChangeCount;
		private bool HasActivatedStore;

		private bool IsInsideMiddlewareChange => BeginMiddlewareChangeCount > 0;

		public Store()
		{
			BrowserInterop.PageLoaded += OnPageLoaded;
		}

		public void AddFeature(IFeature feature)
		{
			if (feature == null)
				throw new ArgumentNullException(nameof(feature));

			FeaturesByName.Add(feature.GetName(), feature);
		}

		public async Task DispatchAsync(IAction action)
		{
			if (action == null)
				throw new ArgumentNullException(nameof(action));

			// Do not allow task dispatching inside a middleware-change.
			// These change cycles are for things like "jump to state" in Redux Dev Tools
			// and should be short lived.
			// We avoid dispatching inside a middleware change because we don't want UI events (like component Init)
			// that trigger actions (such as fetching data from a server) to execute
			if (IsInsideMiddlewareChange)
				return;

			if (!HasActivatedStore)
				throw new InvalidOperationException("Store has not been initialized. Add `@Store.Initialize()` to your layout page");

			var actionsToDispatch = new Queue<IAction>();
			actionsToDispatch.Enqueue(action);

			while (actionsToDispatch.Any())
			{
				IAction currentActionToDispatch = actionsToDispatch.Dequeue();

				// Allow middlewares to veto the dispatching of an action
				if (Middlewares.Any(x => !x.MayDispatchAction(currentActionToDispatch)))
					break;

				ExecuteMiddlewareBeforeDispatch(currentActionToDispatch);

				// Notify all features of this action
				foreach (var featureInstance in FeaturesByName.Values)
				{
					NotifyFeatureOfDispatch(featureInstance, currentActionToDispatch);
				};
				FluxorComponent.AllStateHasChanged();

                IEnumerable<IAction> actionsCreatedByMiddlewares =
                    ExecuteMiddlewareAfterDispatch(currentActionToDispatch)
                    ?? new IAction[0];

                // Get any actions generated by side-effects
                IEnumerable<IAction> actionsCreatedBySideEffects =
                    await TriggerEffects(currentActionToDispatch);

                // Now execute any new actions
                IEnumerable<IAction> allNewActionsToDispatch =
                    actionsCreatedByMiddlewares.Union(actionsCreatedBySideEffects);
				foreach (IAction newActionToDispatch in allNewActionsToDispatch)
					actionsToDispatch.Enqueue(newActionToDispatch);
			}
		}

		public void AddEffect(Type actionType, IEffect effect)
		{
			if (actionType == null)
				throw new ArgumentNullException(nameof(actionType));
			if (effect == null)
				throw new ArgumentNullException(nameof(effect));

			Type genericType = typeof(IEffect<>).MakeGenericType(actionType);
			if (!genericType.IsAssignableFrom(effect.GetType()))
				throw new ArgumentException($"Effect {effect.GetType().Name} does not implement IEffect<{actionType.Name}>");

			List<IEffect> effects = GetEffectsForActionType(actionType, true);
			effects.Add(effect);
		}

		public void AddMiddleware(IMiddleware middleware)
		{
			Middlewares.Add(middleware);
			ReversedMiddlewares.Insert(0, middleware);
			// Initialize the middleware immediately if the store has already been initialized, otherwise this will be
			// done the first time DispatchAsync is called
			if (HasActivatedStore)
			{
				middleware.Initialize(this);
				middleware.AfterInitializeAllMiddlewares();
			}
		}

		public IDisposable BeginInternalMiddlewareChange()
		{
			BeginMiddlewareChangeCount++;
			IEnumerable<IDisposable> disposables = Middlewares.Select(x => x.BeginInternalMiddlewareChange());
			return new DisposableCallback(() =>
			{
				BeginMiddlewareChangeCount--;
				disposables.ToList().ForEach(x => x.Dispose());
			});
		}

		public RenderFragment Initialize()
		{
			return (RenderTreeBuilder renderer) =>
			{
				int sequence = 0;
				foreach(IMiddleware middleware in Middlewares)
				{
					sequence++;
					string middlewareScript = middleware.GetClientScripts();
					if (middlewareScript != null)
					{
						renderer.OpenElement(sequence, "script");
						renderer.AddContent(sequence, $"// Middleware scripts: {middleware.GetType().FullName}\r\n{middlewareScript}");
						renderer.CloseElement();
					}
				}

				renderer.OpenElement(sequence++, "script");
				renderer.AddContent(sequence, GetClientScripts());
				renderer.CloseElement();
			};
		}

		private List<IEffect> GetEffectsForActionType(Type actionType, bool createIfNonExistent)
		{
			EffectsByActionType.TryGetValue(actionType, out List<IEffect> effects);
			if (createIfNonExistent && effects == null)
			{
				effects = new List<IEffect>();
				EffectsByActionType[actionType] = effects;
			}
			return effects;
		}

		private async Task<IEnumerable<IAction>> TriggerEffects(IAction action)
		{
			var allActionsCreatedByAllSideEffects = new List<IAction>();

			IEnumerable<IEffect> effectsForAction = GetEffectsForActionType(action.GetType(), false);
			if (effectsForAction != null && effectsForAction.Any())
			{
				foreach (var effect in effectsForAction)
				{
					IAction[] actionsFromSideEffect = await effect.HandleAsync(action);
					if (actionsFromSideEffect != null)
					{
						foreach (IAction actionFromSideEffect in actionsFromSideEffect)
						{
							if (actionFromSideEffect != null)
								allActionsCreatedByAllSideEffects.Add(actionFromSideEffect);
						}
					}
				}
			}

			return allActionsCreatedByAllSideEffects;
		}

		private void InitializeMiddlewares()
		{
			Middlewares.ForEach(x => x.Initialize(this));
			Middlewares.ForEach(x => x.AfterInitializeAllMiddlewares());
		}

		private void ExecuteMiddlewareBeforeDispatch(IAction actionAboutToBeDispatched)
		{
			foreach (IMiddleware middleWare in Middlewares)
				middleWare.BeforeDispatch(actionAboutToBeDispatched);
		}

		private IEnumerable<IAction> ExecuteMiddlewareAfterDispatch(IAction actionJustDispatched)
		{
            IEnumerable<IAction> actionsToDispatch = 
                Middlewares.SelectMany(x => x.AfterDispatch(actionJustDispatched));
            return actionsToDispatch;
		}

		private void NotifyFeatureOfDispatch(IFeature feature, IAction action)
		{
			string methodName = nameof(IFeature.ReceiveDispatchNotificationFromStore);
			// We need the generic method for the feature instance
			MethodInfo methodInfo = feature
				.GetType()
				.GetMethod(methodName)
				.MakeGenericMethod(action.GetType());

			methodInfo.Invoke(feature, new object[] { action });
		}

		private void ActivateStore()
		{
			if (HasActivatedStore)
				return;

			HasActivatedStore = true;
			InitializeMiddlewares();
			DispatchAsync(new StoreInitializedAction()).Wait();
		}

		private string GetClientScripts()
		{
			return BrowserInterop.GetClientScripts();
		}

		private void OnPageLoaded(object sender, EventArgs e)
		{
			BrowserInterop.PageLoaded -= OnPageLoaded;
			ActivateStore();
		}
	}
}
